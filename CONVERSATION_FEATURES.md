# 對話記錄和摘要功能說明

## 概述

FaceHeartAGI v3.0 新增了完整的對話記錄和智能摘要功能，實現了以下需求：

1. **記錄歷史對話紀錄** - 自動記錄每輪對話的用戶問題和系統回應（最多保存10輪）
2. **固定對前5輪進行總結摘要** - 使用LLM對前5輪對話生成簡潔摘要，僅包含「用戶意圖」與「系統回應結論」
3. **智能歷史管理** - 當歷史長度 > 5 時，傳入LLM的歷史紀錄數量為 `len(conversations) - 5`，並加上總結摘要
4. **LLM參考歷史對話** - LLM在回答時能夠參考先前的對話內容，提供更連貫和個人化的回應

## 新增功能

### 1. 對話歷史記錄

- **自動記錄**: 每次API調用都會自動記錄對話內容
- **會話管理**: 使用 `session_id` 來區分不同的對話會話
- **詳細資訊**: 記錄時間戳記、檢索類型、知識庫使用情況等元數據
- **完整追蹤**: 追蹤每輪對話的完整脈絡

### 2. 智能摘要生成

- **觸發機制**: 每5輪對話自動觸發摘要生成
- **固定範圍**: 固定對前5輪對話進行總結摘要
- **內容精簡**: 僅摘要「用戶意圖」與「系統回應結論」
- **AI驅動**: 使用LLM生成高質量摘要
- **累積保存**: 多個摘要累積保存，形成完整的對話脈絡

### 3. 會話管理系統

- **多會話支援**: 同時管理多個不同的對話會話
- **會話隔離**: 每個會話的記錄完全獨立
- **靈活查詢**: 支援按會話ID查詢歷史和摘要
- **資料匯出**: 支援完整對話記錄的JSON格式匯出

### 4. LLM歷史對話參考

- **上下文感知**: LLM能夠參考之前的對話內容
- **智能歷史管理**: 當對話超過5輪時，自動使用最近幾輪加上摘要
- **連貫性回應**: 提供與之前對話相關聯的回應
- **個人化建議**: 基於用戶的歷史問題提供更精準的建議
- **智能引用**: 能夠適當引用之前的建議和資訊
- **健康狀況追蹤**: 能夠追蹤用戶健康狀況的變化趨勢
- **動態建議調整**: 根據健康狀況變化調整建議內容

## 新增API端點

| 端點 | 方法 | 說明 |
|------|------|------|
| `/conversation-history` | POST | 獲取指定會話的對話歷史 |
| `/conversation-summaries` | POST | 獲取指定會話的摘要列表 |
| `/export-conversation` | POST | 匯出完整的對話記錄和摘要 |
| `/clear-session` | DELETE | 清除指定會話的所有記錄 |

## 資料結構

### 對話記錄結構

```json
{
  "turn_number": 1,
  "timestamp": "2024-01-15T10:30:00",
  "user_intent": "用戶問題內容",
  "system_response": "系統回應內容",
  "fhir_data": {
    "patient": {...},
    "conditions": [...],
    "observations": [...],
    "medications": [...]
  }
}
```

### 摘要結構

```json
{
  "summary_id": 1,
  "turns_covered": [1, 2, 3, 4, 5],
  "user_intent_summary": "用戶主要關注高血壓的飲食建議和生活方式調整",
  "health_status_changes": "血壓從150/95改善到135/85，但後期出現糖尿病併發症",
  "system_response_summary": "系統提供了具體的飲食建議和運動指導，並根據病情變化調整用藥建議",
  "generated_at": "2024-01-15T10:35:00"
}
```

## 使用方式

### 1. 基本使用

所有API請求現在都需要包含 `session_id` 參數：

```json
{
  "session_id": "unique_session_id",
  "user_question": "高血壓患者應該注意什麼？",
  "fhir_data": {...},
  "retrieval_type": "vector"
}
```

### 2. 查看對話歷史

```bash
curl -X POST "http://localhost:8000/conversation-history" \
  -H "Content-Type: application/json" \
  -d '{"session_id": "your_session_id"}'
```

### 3. 查看摘要

```bash
curl -X POST "http://localhost:8000/conversation-summaries" \
  -H "Content-Type: application/json" \
  -d '{"session_id": "your_session_id"}'
```

### 4. 匯出對話記錄

```bash
curl -X POST "http://localhost:8000/export-conversation" \
  -H "Content-Type: application/json" \
  -d '{"session_id": "your_session_id"}'
```

## 技術實現

### 1. ConversationManager 類

- **核心功能**: 管理對話記錄和摘要生成
- **異步支援**: 支援異步摘要生成，不阻塞主要API響應
- **記憶體管理**: 在記憶體中管理對話狀態
- **可擴展性**: 設計支援未來的持久化儲存
- **歷史格式化**: 提供多種格式的歷史對話輸出

### 2. 歷史對話整合

- **提示詞增強**: 在提示詞中自動加入歷史對話內容
- **上下文傳遞**: 將歷史對話傳遞給LLM進行參考
- **智能截斷**: 自動控制歷史對話長度，避免提示詞過長
- **格式標準化**: 統一的歷史對話格式便於LLM理解

### 3. 摘要生成邏輯

- **觸發條件**: 每5輪對話自動觸發
- **固定範圍**: 固定對前5輪對話進行摘要
- **提示工程**: 專門設計的提示詞確保摘要質量
- **內容過濾**: 僅保留用戶意圖和系統結論
- **格式標準化**: 統一的摘要格式便於後續處理

### 4. 串流回應處理

- **內容收集**: 在串流過程中收集完整回應內容
- **非阻塞記錄**: 記錄操作不影響串流響應速度
- **錯誤處理**: 完善的錯誤處理機制
- **歷史整合**: 在生成回應時自動整合歷史對話
- **記憶體管理**: 最多保存10輪對話，自動移除最舊的記錄

## 範例腳本

### 1. 基本使用範例

檔案: `example_usage_v3.py`
- 已更新為包含 `session_id` 參數
- 展示基本的API使用方式

### 2. 對話功能範例

檔案: `example_usage_conversation.py`
- 完整展示對話記錄功能
- 示範7輪對話的完整流程
- 展示摘要生成和匯出功能

### 3. 歷史對話上下文範例

檔案: `example_conversation_context.py`
- 展示LLM如何利用歷史對話提供連貫回應
- 進行多輪相關對話示範
- 比較有無歷史對話的回應差異
- 分析對話連貫性

### 4. FHIR資料歷史對話範例

檔案: `example_fhir_history.py`
- 展示FHIR資料在歷史對話中的作用
- 使用不同健康狀況的FHIR資料進行對話
- 展示LLM如何根據健康狀況變化提供建議
- 展示摘要中的健康狀況變化分析

### 5. 新摘要邏輯範例

檔案: `example_new_summary_logic.py`
- 展示新的摘要邏輯：最多保存10輪對話
- 演示固定對前5輪進行摘要
- 展示當對話超過5輪時的歷史管理邏輯
- 演示記憶體管理和對話輪次重新編號

## 配置選項

### 摘要觸發頻率

目前設定為每5輪對話觸發摘要生成，可以在 `ConversationManager` 中修改：

```python
# 在 add_conversation_turn 方法中
if len(self.conversations[session_id]) % 5 == 0:  # 修改這裡的數字
```

### 摘要內容自定義

可以在 `ConversationManager._build_summary_prompt` 方法中調整摘要生成的提示詞。

### 歷史對話長度控制

新的邏輯自動控制歷史對話長度：

```python
# 如果對話輪數 <= 5，返回所有對話
if len(conversations) <= 5:
    recent_conversations = conversations
else:
    # 如果對話輪數 > 5，返回最近幾輪（len(conversations) - 5）
    recent_count = len(conversations) - 5
    recent_conversations = conversations[-recent_count:]
```

### 記憶體管理配置

可以在 `ConversationManager` 中調整最大保存的對話輪數：

```python
# 在 __init__ 方法中
self.max_conversations = 10  # 修改這裡的數字來控制最大保存輪數
```

## 注意事項

1. **會話ID管理**: 請確保為每個獨立的對話會話使用唯一的 `session_id`
2. **記憶體使用**: 當前實現在記憶體中儲存對話記錄，最多保存10輪，自動管理記憶體使用
3. **異步執行**: 摘要生成是異步執行的，不會阻塞API響應
4. **錯誤處理**: 即使摘要生成失敗，也不會影響正常的對話記錄
5. **歷史對話管理**: 自動管理歷史對話長度，對話超過5輪時使用最近幾輪加上摘要
6. **提示詞長度**: 歷史對話會增加提示詞長度，但新邏輯自動控制長度避免過長
7. **對話輪次編號**: 當達到最大保存輪數時，會自動重新編號對話輪次

## 後續開發建議

1. **持久化儲存**: 考慮將對話記錄儲存到資料庫
2. **摘要自定義**: 允許用戶自定義摘要觸發條件和內容格式
3. **搜索功能**: 在對話歷史中添加搜索功能
4. **統計分析**: 添加對話統計和分析功能
5. **匯出格式**: 支援更多匯出格式（如PDF、CSV等）
6. **智能歷史選擇**: 根據當前問題智能選擇相關的歷史對話
7. **對話記憶優化**: 實現更高效的對話記憶管理機制

## 測試建議

1. 執行 `python example_usage_conversation.py` 來測試完整功能
2. 執行 `python example_conversation_context.py` 來測試歷史對話上下文功能
3. 執行 `python example_fhir_history.py` 來測試FHIR資料歷史對話功能
4. 執行 `python example_new_summary_logic.py` 來測試新的摘要邏輯
5. 使用不同的 `session_id` 測試會話隔離
6. 測試5輪對話後的摘要生成
7. 測試對話記錄的匯出功能
8. 測試會話清除功能
9. 測試多輪相關對話的連貫性
10. 比較有無歷史對話的回應差異
11. 測試健康狀況變化對建議的影響
12. 測試超過10輪對話的記憶體管理
13. 測試對話輪次重新編號功能
14. 測試新歷史管理邏輯（超過5輪時使用最近幾輪加上摘要） 